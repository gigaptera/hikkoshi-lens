## 1. 通勤時間計算ロジック (Commute Logic)
**担当**: Go (Backend)
**目的**: ユーザーごとに異なる「勤務地」からの所要時間を算出する。開発フェーズに応じて実装を差し替える **Strategy Pattern** を採用する。

### Phase 1: 簡易計算 (Linear Calculator)
APIコストを削減し、高速に概算を出すためのロジック。

- **計算式**:
  $$Time = \frac{Distance_{linear} \times DetourFactor}{Speed_{average}}$$
- **パラメータ定義**:
    - `Distance_linear`: ハーバースイン公式 (Haversine Formula) で求めた2点間の直線距離 (km)。
    - `DetourFactor`: **1.3** (直線距離に対する迂回率の近似値)。
    - `Speed_average`: **25km/h** (約416m/分。都市部の電車+徒歩の平均移動速度として設定)。
- **実装イメージ (Go)**:
    - `haversine(lat1, lon1, lat2, lon2)` 関数を実装。
    - インターフェース `Calculate(from, to)` を満たす構造体を作成。

### Phase 2: 正確計算 (API Calculator)
リリース後や課金ユーザー向けの高精度ロジック。

- **データソース**: Mapbox Matrix API / Google Routes API
- **ロジック**: 実際の公共交通機関（Transit）モードでの所要時間を取得。
- **切替方法**: GoのDIコンテナ初期化時に注入する構造体を `Linear` から `Api` へ変更するのみ。

---

## 2. 駅総合スコア算出フロー (Station Scoring Flow)
**担当**: Go (Backend) & Next.js (Frontend)
**目的**: ユーザーの「重み」変更に対して、0.5秒以内でランキングを再描画するパフォーマンスを実現する。

### データ構造と役割分担

| 項目 | データの種類 | 担当 | 内容 |
| :--- | :--- | :--- | :--- |
| **A. 静的スコア** | Param (素点) | **Go (DB)** | 駅ごとに固定された0-100のスコア。<br>(家賃、治安、利便性、趣味) |
| **B. 動的スコア** | Commute Score | **Go (Calc)** | 通勤時間(分)をスコア(0-100)に変換したもの。<br>`100 - (時間 - 理想) * 減点係数` 等。 |
| **C. ユーザー重み** | Weight (係数) | **Frontend** | 診断結果に基づく％配分。<br>(例: 通勤40%, 家賃30%, その他30%) |

### 算出プロセス (Sequence)

```mermaid
sequenceDiagram
    participant UI as Next.js (Client)
    participant API as Go API
    participant DB as Supabase

    Note over UI: ユーザーが重み(Weight)を変更

    UI->>API: 1. 勤務地検索 (Search Request)
    API->>DB: 駅パラメータ取得 (Static Params)
    DB-->>API: {rent: 80, safety: 60...}
    API->>API: 通勤時間計算 (Commute Calc)
    API-->>UI: JSON配列 {id, name, params: {...}, commute_time: 35}

    Note over UI: ここからフロントエンド処理

    UI->>UI: 2. 総合スコア計算 (Realtime)<br>Score = Σ(Param * Weight)
    UI->>UI: 3. ソート & ランキング表示